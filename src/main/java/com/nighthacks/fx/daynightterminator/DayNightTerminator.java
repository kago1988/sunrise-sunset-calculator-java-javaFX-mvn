/*
 * Copyright Â© 2011,2015 Liquid Robotics
 * Licensed under Apache 2.0 https://github.com/JamesGosling/DayNightTerminator/blob/master/LICENSE
 * In the test directory (src/test/java/com/liquidr/daynightterminator) you'll
 * find two main programs: TestColor.java and TestGrey.java.  Run either of them to
 * see a test run of this Node, and a slider to move back and forth in time.
 * 
 * Created by James Gosling, based on the matlab code from
 * http://caia.swin.edu.au/mapping/gametraffic/anim100309A/plotdaynightterminator.m
 * 
 * 
 * %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 * % Copyright (c) 2009-2012, Centre for Advanced Internet Architectures
 * % Swinburne University of Technology, Melbourne, Australia
 * % (CRICOS number 00111D).
 * %
 * %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 * %
 * % plotdaynightterminator.m
 * % A script for Matlab to draw the Day-Night terminator and the night shadow upon
 * % a map created with the following two commands of the Mapping Toolbox:
 * %
 * % load coast;
 * % mapshow(long,lat,'Color','black');
 * %
 * % The function will calculate the day-night terminator based on the GMT (UTC) date.
 * % It will draw the terminator which fits the map created using the mapshow command,
 * % and fill the night part of the map with a dark gray colour.
 * % The effect is similar to http://www.timeanddate.com/worldclock/sunearth.html and
 * % http://www.daylightmap.com/index.php
 * %
 * % The script needs the equinox information for the years it applies.
 * % Currently only the 2009 and 2010 equinox information are included.
 * % more equinox information can be found at:
 * % http://www.timeanddate.com/calendar/seasons.html
 * % (don't forget to switch to GMT at the bottom of the page)
 * %
 * % This script has been generated by following hints, tips and scripts found at:
 * % http://www.geoastro.de/elevaz/basics/index.htm
 * %
 * % This file is part of the animation_scripts.tar.gz tarball that can be obtained at:
 * % http://caia.swin.edu.au/sting/tools/
 * %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 * %
 * % This software was developed by Mattia Rossi <mrossi@swin.edu.au>
 * %
 * % This software has been made possible in part by a grant from
 * % APNIC Pty. Ltd., Canberra, Australia. http://www.apnic.net/
 * %
 * % All rights reserved.
 * %
 * % Redistribution and use in source and binary forms, with or without
 * % modification, are permitted provided that the following conditions
 * % are met:
 * % 1. Redistributions of source code must retain the above copyright
 * %    notice, this list of conditions and the following disclaimer.
 * % 2. Redistributions in binary form must reproduce the above copyright
 * %    notice, this list of conditions and the following disclaimer in the
 * %    documentation and/or other materials provided with the distribution.
 * % 3. The names of the authors, the "Centre for Advanced Internet Architecture"
 * %    and "Swinburne University of Technology" may not be used to endorse
 * %    or promote products derived from this software without specific
 * %    prior written permission.
 * %
 * % THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS "AS IS" AND
 * % ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * % IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * % ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
 * % FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * % DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * % OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * % HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * % LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * % OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * % SUCH DAMAGE.
 */
package com.nighthacks.fx.daynightterminator;

import static java.lang.Math.*;
import java.util.*;
import java.util.concurrent.*;
import javafx.collections.*;
import javafx.geometry.*;
import javafx.scene.*;
import javafx.scene.image.*;
import javafx.scene.input.*;
import javafx.scene.layout.*;
import javafx.scene.paint.*;
import javafx.scene.shape.*;
import javafx.scene.transform.*;

/**
 * DayNightTerminator is a JavaFX Node that draws a simple map of the world with
 * an indication of what parts of the map are in daylight, and which parts are dark.
 * It's designed to be useable as a small course whole-world pop-up over other FX Nodes
 * to allow approximate location selection.
 * 
 * Based on some matlab code by Mattia Rossi &lt;mrossi@swin.edu.au&gt; of
 * Swinburn University
 */
public class DayNightTerminator extends AnchorPane {
    /**
     * @return a DayNightTerminator that uses colorful maps based on NASA's
     * Blue Marble imagery
     */
    public static DayNightTerminator colorful() {
        return new DayNightTerminator(
                DayNightTerminator.class.getResource("night.png").toString(), 
                DayNightTerminator.class.getResource("day.jpg").toString());
    }
    /**
     * @return a DayNightTerminator that uses somewhat subdued grey-scale world maps
     */
    public static DayNightTerminator greyscale() {
        return new DayNightTerminator(
                DayNightTerminator.class.getResource("nightGrey.png").toString(), 
                DayNightTerminator.class.getResource("dayGrey.png").toString());
    }
    /**
     * Creates a DayNightTerminator based on day and night images of your
     * choosing.
     * 
     * @param dayImageURL   URL of the image to be used for the daylit parts of the map
     * @param nightImageURL URL of the image to be used for the nighttime parts of the map
     */
    public DayNightTerminator(String dayImageURL, String nightImageURL) {
        dayImage = new ImageView(dayImageURL);
        nightImage = new ImageView(nightImageURL);
        init(System.currentTimeMillis());
    }
    private void init(long t) { // to avoid complains about overridable methods
        widthProperty().addListener((n) -> setTransform());
        heightProperty().addListener((n) -> setTransform());
        setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
        setPrefSize(360, 180);
        dayImage.setPreserveRatio(false);
        dayImage.setSmooth(true);
        dayImage.setCache(true);
        dayImage.fitWidthProperty().set(360);
        dayImage.fitHeightProperty().set(180);
        nightImage.setPreserveRatio(false);
        nightImage.setSmooth(true);
        nightImage.setCache(true);
        nightImage.fitWidthProperty().set(360);
        nightImage.fitHeightProperty().set(180);
//        nightImage.setOpacity(1);
        getChildren().add(dayImage);
        getChildren().add(nightImage);
        setOnMousePressed((l)->select(l));
        setOnMouseDragged((l)->select(l));
        setOnMouseReleased((l)->select(l));
        setTime(t);
    }
    private void select(MouseEvent me) {
        CopyOnWriteArrayList<MapSelectionListener> l = listeners;
        if(l!=null) {
            final double latitude = 90-me.getY();
            final double longitude = me.getX()-180;
            select(latitude, longitude);
                l.forEach((msl)->msl.locationSelected(latitude, longitude));
        }
    }
    private CopyOnWriteArrayList<MapSelectionListener> listeners;
    /**
     * Add a listener for UI events that select a point on the map.
     * @param msl listener to be informed on a mouse click
     */
    public void addMapSelectionListener(MapSelectionListener msl) {
        if(listeners==null) listeners = new CopyOnWriteArrayList<>();
        listeners.add(msl);
    }

    /**
     *
     * @param msl listener to no longer be informed on a mouse click
     */
    public void removeMapSelectionListener(MapSelectionListener msl) {
        if(listeners!=null) {
            listeners.remove(msl);
            if(listeners.isEmpty()) listeners = null;
        }
    }

    public interface MapSelectionListener {

        /**
         * @param latitude selected point on globe
         * @param longitude selected point on globe
         */
        public void locationSelected(double latitude, double longitude);
    }
    /**
     * Sets the time being displayed as day/night indications on the map.
     * @param t time that the day/night division should correspond too
     */
    public final void setTime(long t) {
        if (abs(t - displayedTime) < 2 * 60 * 1000)
            return; // Don't bother with small changes
        double[] c0 = DayNightTerminator.computeDayNightTerminator(t);
        int len = c0.length;
        double[] c1 = new double[len * 2 + 4];
        int pos = 0;
        for (int i = 0; i < len; i++) {
            c1[pos++] = (double) i;
            c1[pos++] = c0[i];
        }
        final double inyear = yearfraction(t);
        double y = inyear >= vernalEquinox && inyear <= autumnalEquinox
                   ? 0
                   : 180;
        c1[pos++] = len - 1.;
        c1[pos++] = y;
        c1[pos++] = 0.;
        c1[pos++] = y;
        nightImage.setClip(new Polygon(c1));
        displayedTime = t;
    }

    private static double[] computeDayNightTerminator(long t) {
        // The nice thing about the java time standard is that converting it
        // to a julian date is trivial - unlike the gyrations the original
        // matlab code had to go through to convert the y/n/d/h/m/s parameters
        final double julianDate1970 = t / (double) (1000 * 60 * 60 * 24);
        // convert from the unix epoch to the astronomical epoch
        // (noon on January 1, 4713 BC, GMT/UT) (the .5 is noon versus midnight)
        final double juliandate = julianDate1970 + 2440587.500000;
        final double K = PI / 180;
        // here be dragons!
        final double T = (juliandate - 2451545.0) / 36525;
        double L = 280.46645 + 36000.76983 * T + 0.0003032 * T * T;
        L = L % 360;
        if (L < 0)
            L = L + 360;
        double M = 357.52910 + 35999.05030 * T - 0.0001559 * T * T -
                0.00000048 * T * T * T;
        M = M % 360;
        if (M < 0)
            M = M + 360;
        final double C = (1.914600 - 0.004817 * T - 0.000014 * T * T) * sin(K * M) +
                 (0.019993 - 0.000101 * T) * sin(K * 2 * M) +
                 0.000290 * sin(K * 3 * M);
        final double theta = L + C;
        final double LS = L;
        final double LM = 218.3165 + 481267.8813 * T;
        final double eps0 = 23.0 + 26.0 / 60.0 + 21.448 / 3600.0 -
                (46.8150 * T +
                0.00059 * T * T - 0.001813 * T * T * T) / 3600;
        final double omega = 125.04452 - 1934.136261 * T + 0.0020708 * T * T +
                T * T *
                T / 450000;
        final double deltaEps =
                (9.20 * cos(K * omega) + 0.57 * cos(K * 2 * LS) +
                0.10 * cos(K * 2 * LM) - 0.09 * cos(K * 2 * omega)) / 3600;
        final double eps = eps0 + deltaEps + 0.00256 *
                cos(K * (125.04 - 1934.136 * T));
        final double lambda = theta - 0.00569 - 0.00478 * sin(K * (125.04 -
                1934.136 *
                T));
        final double delta = asin(sin(K * eps) * sin(K * lambda));
        final double dec = delta / K;
        final double tau = (juliandate - floor(juliandate)) * 360;
        double[] coords = new double[361];
        for (int i = 0; i < 361; i++)
            coords[i] = atan(cos((i - 180 + tau) * K) / tan(dec * K)) / K + 90;
        return coords;
    }
    /**
     * Select(highlight) the given lat/lon pair on the map.
     * @param latitude coordinate to be highlighted
     * @param longitude coordinate to be highlighted
     */
    public void select(double latitude, double longitude) {
        // Very conveniently :-) the coordinate system inside the anchorpane is
        // Lat/lon degrees
        if(highlight==null) setSelectIndicatorCircle(5);
        highlight.setTranslateX(longitude+180);
        highlight.setTranslateY(90-latitude);
    }
    private void setTransform() {
        ObservableList<Transform> xforms = getTransforms();
        if (prevTransform != null) xforms.remove(prevTransform);
        xforms.add(prevTransform = new Scale(
                widthProperty().doubleValue() / 360,
                heightProperty().doubleValue() / 180));
        if(highlight instanceof Shape && strokeWidthPixels>0) {
            /* Normally, stroke widths scale with the transform.  But we don't
             * want this, so we tweak the width so that it cancels out. */
            Point2D p = getLocalToParentTransform().deltaTransform(new Point2D(1, 1));
            ((Shape)highlight).setStrokeWidth(strokeWidthPixels/max(p.getX(),p.getY()));
        }
    }
    private double strokeWidthPixels = 2;
    /**
     * If the selection indicator is a Shape, this will cause it's stroke width
     * to be set in pixels, and *not* scale with the rest of the map.  The
     * default behavior is setStrokeWidthPixels(2)
     * @param w stroke width in pixels
     * @return this
     */
    public DayNightTerminator setStrokeWidthPixels(double w) {
        if(w != strokeWidthPixels) {
            strokeWidthPixels = w;
            setTransform();
        }
        return this;
    }
    /**
     * Set the indicator to be used when a lat/lon pair is selected.
     * This Node will have its 0,0 point translated to the selected lat/lon.
     * @param n node to overlay and position on map
     * @return this
     */
    public DayNightTerminator setSelectIndicator(Node n) {
        if(n != highlight) {
            if(highlight!=null)
                getChildren().remove(highlight);
            if(n!=null)
                getChildren().add(n);
            highlight = n;
        }
        return this;
    }
    /**
     * Set the indicator to be used when a lat/lon pair is selected
     * to a circle of radius r degrees.  setSelectIndicatorCircle(5) is the default
     * behavior.
     * @param r radius of circle
     * @return this
     */
    public DayNightTerminator setSelectIndicatorCircle(double r) {
        Circle c = new Circle(0,0,r);
        c.setStroke(Color.BLACK);
        c.setStrokeWidth(2);
        c.setFill(null);
        return setSelectIndicator(c);
    }
    /**
     * Set the indicator to be used when a lat/lon pair is selected
     * to cross-hairs that extend r degrees from the selected point.
     * @param r radius of cross-hairs
     * @return this
     */
    public DayNightTerminator setSelectIndicatorCrosshairs(double r) {
        Path p = new Path(
                new MoveTo(-r, 0),
                new LineTo(r,0),
                new MoveTo(0,-r),
                new LineTo(0,r)
        );
        p.setStroke(Color.BLACK);
        p.setStrokeWidth(2);
        p.setFill(null);
        return setSelectIndicator(p);
    }
    private static double yearfraction(long t) {
        double y = t / (365.2425 * 24 * 60 * 60 * 1000);  // fractional years since the epoch
        return y - floor(y);
    }
    private static final double vernalEquinox = yearfraction(Date
            .parse("March 20, 2016 04:30 UTC"));
    private static final double autumnalEquinox = yearfraction(Date
            .parse("September 22, 2016 14:21 UTC"));
    private Transform prevTransform = null;
    private long displayedTime = 0;
    private final ImageView nightImage, dayImage;
    private Node highlight;
}
